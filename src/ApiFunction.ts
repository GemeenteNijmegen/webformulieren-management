import { aws_lambda as Lambda, aws_dynamodb, RemovalPolicy, Duration, Stack } from 'aws-cdk-lib';
import { Alarm } from 'aws-cdk-lib/aws-cloudwatch';
import { IRole } from 'aws-cdk-lib/aws-iam';
import { LayerVersion } from 'aws-cdk-lib/aws-lambda';
import { FilterPattern, IFilterPattern, MetricFilter, RetentionDays } from 'aws-cdk-lib/aws-logs';
import { Construct } from 'constructs';

type T = Lambda.Function;

export interface ApiFunctionProps {
  apiFunction: {new(scope: Construct, id:string, props?: Lambda.FunctionProps): T };
  description: string;
  environment?: {[key: string]: string};
  role?: IRole;
}

export class ApiFunction extends Construct {
  lambda: Lambda.Function;

  constructor(scope: Construct, id: string, props: ApiFunctionProps) {
    super(scope, id);

    // See https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Lambda-Insights-extension-versionsx86-64.html
    const insightsArn = `arn:aws:lambda:${Stack.of(this).region}:580247275435:layer:LambdaInsightsExtension:21`;

    this.lambda = new props.apiFunction(this, 'lambda', {
      runtime: Lambda.Runtime.NODEJS_18_X, // Required but overwritten
      handler: 'index.handler', // Required but overwritten
      code: Lambda.Code.fromInline('empty'), // required but overwritten
      description: props.description,
      role: props.role,
      memorySize: 512,
      insightsVersion: Lambda.LambdaInsightsVersion.fromInsightVersionArn(insightsArn),
      logRetention: RetentionDays.ONE_MONTH,
      environment: {
        ...props.environment,
      },
    });

  }

  /**
   * Add the shared resources layer that is constructed for this webapp.
   * @param layer
   */
  addLambdaLayer(layer: LayerVersion) {
    this.lambda.addLayers(layer);
  }

  /**
   * Grant access to the session store and add SESSION_TABLE environment variable
   * @param table
   */
  allowSessionAccess(table: aws_dynamodb.ITable) {
    this.lambda.addEnvironment('SESSION_TABLE', table.tableName);
    table.grantReadWriteData(this.lambda.grantPrincipal);
  }

  /**
   * Add session env variable.
   * @param minutes
   */
  setSessionLifetime(minutes: number) {
    this.lambda.addEnvironment('SESSION_TTL_MIN', minutes.toString());
  }

  /**
   * Add standard environment variables to the lambda
   * @param applicationName
   */
  addStandardEnvironment(applicationName: string) {
    this.lambda.addEnvironment('WEBAPP_NAME', applicationName);
  }

  /**
   * Monitor the logs generated by this function for a filter pattern, generate metric
   * and alarm on increased error rate.
   *
   * @param filterPattern Pattern to filter by (default: containing ERROR)
   */
  monitor(applicationName: string, filterPattern?: IFilterPattern) {
    const errorMetricFilter = new MetricFilter(this, 'MetricFilter', {
      logGroup: this.lambda.logGroup,
      metricNamespace: `${applicationName}/${this.node.id}`,
      metricName: 'Errors',
      filterPattern: filterPattern ?? FilterPattern.anyTerm('ERROR'),
      metricValue: '1',
    });
    errorMetricFilter.applyRemovalPolicy(RemovalPolicy.DESTROY);

    const alarm = new Alarm(this, `${applicationName}-${this.node.id}-alarm`, {
      metric: errorMetricFilter.metric({
        statistic: 'sum',
        period: Duration.minutes(5),
      }),
      evaluationPeriods: 3,
      threshold: 5,
      alarmName: `Increased error rate for ${this.node.id}`,
      alarmDescription: `This alarm triggers if the function ${this.node.id} is logging more than 5 errors over n minutes.`,
    });
    alarm.applyRemovalPolicy(RemovalPolicy.DESTROY);
  }

}
